# Introdução aos Padrões de Criação

## O que são Padrões de Criação?

Padrões de criação são um grupo de padrões de design que tratam do processo de instanciação de objetos. Eles ajudam a
abstrair o processo de criação, tornando um sistema independente de como seus objetos são criados, compostos e
representados. Isso é particularmente útil para lidar com a complexidade da criação de objetos e promover a
flexibilidade e reutilização do código.

## Importância dos Padrões de Criação

A criação de objetos é uma parte fundamental do desenvolvimento de software, mas pode se tornar complexa quando envolve
a configuração de objetos com muitos parâmetros, a gestão de dependências ou a necessidade de criar objetos em
diferentes contextos. Padrões de criação ajudam a resolver esses desafios, proporcionando soluções padronizadas que
facilitam a manutenção e a escalabilidade do software.

### Principais Benefícios

1. **Encapsulamento da Criação:** Eles encapsulam a lógica de criação, permitindo que o código cliente se concentre em
   usar os objetos em vez de saber como eles são criados.
2. **Desacoplamento:** Promovem o desacoplamento entre a aplicação e a maneira como os objetos são criados, facilitando
   mudanças futuras.
3. **Reutilização:** Facilitam a reutilização de código ao permitir que diferentes partes de um sistema usem os mesmos
   padrões de criação.
4. **Flexibilidade:** Permitem a criação de famílias de objetos relacionados, garantindo que o sistema possa ser
   facilmente extensível.

## Tipos de Padrões de Criação

Existem vários padrões de criação, cada um com um propósito específico. Vamos explorar os mais comuns: Singleton,
Factory Method, Abstract Factory, Builder e Prototype.

### Singleton

#### Propósito

O padrão Singleton garante que uma classe tenha apenas uma instância e fornece um ponto de acesso global a essa
instância.

#### Aplicação

É usado em situações onde é necessário um único ponto de controle para um recurso compartilhado, como um gerenciador de
conexão com banco de dados ou um logger.

#### Exemplo

```java
public class Singleton {
    private static Singleton instance;

    private Singleton() {
    }

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

### Factory Method

#### Propósito

O Factory Method define uma interface para criar um objeto, mas permite que subclasses alterem o tipo de objeto que será
criado.

#### Aplicação

É utilizado quando uma classe não pode antecipar a classe dos objetos que deve criar, ou quando uma classe quer que suas
subclasses especifiquem os objetos que cria.

#### Exemplo

```java
public abstract class Creator {
    public abstract Product factoryMethod();

    public void anOperation() {
        Product product = factoryMethod();
        // Operar no produto
    }
}

public class ConcreteCreator extends Creator {
    @Override
    public Product factoryMethod() {
        return new ConcreteProduct();
    }
}
```

### Abstract Factory

#### Propósito

O Abstract Factory fornece uma interface para criar famílias de objetos relacionados ou dependentes sem especificar suas
classes concretas.

#### Aplicação

É usado quando um sistema deve ser independente de como seus produtos são criados e compostos, ou quando o sistema deve
ser configurado com uma dessas famílias de produtos.

#### Exemplo

```java
public interface GUIFactory {
    Button createButton();

    Checkbox createCheckbox();
}

public class WinFactory implements GUIFactory {
    @Override
    public Button createButton() {
        return new WinButton();
    }

    @Override
    public Checkbox createCheckbox() {
        return new WinCheckbox();
    }
}

public class MacFactory implements GUIFactory {
    @Override
    public Button createButton() {
        return new MacButton();
    }

    @Override
    public Checkbox createCheckbox() {
        return new MacCheckbox();
    }
}
```

### Builder

#### Propósito

O Builder separa a construção de um objeto complexo da sua representação, permitindo que o mesmo processo de construção
crie diferentes representações.

#### Aplicação

É útil quando a criação de um objeto envolve vários passos complexos ou configurações, como na construção de um
objeto `Meal` que pode ter vários componentes opcionais.

#### Exemplo

```java
public class Meal {
    private String drink;
    private String mainCourse;
    private String side;

    private Meal(MealBuilder builder) {
        this.drink = builder.drink;
        this.mainCourse = builder.mainCourse;
        this.side = builder.side;
    }

    public static class MealBuilder {
        private String drink;
        private String mainCourse;
        private String side;

        public MealBuilder setDrink(String drink) {
            this.drink = drink;
            return this;
        }

        public MealBuilder setMainCourse(String mainCourse) {
            this.mainCourse = mainCourse;
            return this;
        }

        public MealBuilder setSide(String side) {
            this.side = side;
            return this;
        }

        public Meal build() {
            return new Meal(this);
        }
    }
}
```

### Prototype

#### Propósito

O Prototype permite a criação de novos objetos a partir de um protótipo, clonando uma instância existente.

#### Aplicação

É utilizado quando a criação direta de um objeto é custosa ou complexa, e cloná-lo é uma alternativa eficiente.

#### Exemplo

```java
public class Prototype implements Cloneable {
    private String field;

    public Prototype(String field) {
        this.field = field;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
```

## Conclusão

Os padrões de criação são essenciais para a construção de software robusto e escalável. Eles encapsulam a complexidade
da criação de objetos, promovem o desacoplamento e a reutilização, e facilitam a flexibilidade e a manutenção do código.
Compreender e aplicar esses padrões pode transformar significativamente a eficiência e a qualidade do desenvolvimento de
software, tornando-o mais adaptável às mudanças e mais fácil de gerenciar ao longo do tempo.